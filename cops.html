---
title: The Cops & Robbers Game
description: Three cops and one robber run on a planar undirected graph. The cops and the robber take turns to move. In each move the person runs from one vertex to a neighbor. Can the cops catch the robber?
layout: default
permalink: /cops
---

<svg id="svgroot" width="1000" height="700" onload="makeDraggable(evt)">
</svg>

<script>
    /////////////////////////////////////////////////////////////////////////////////////
    // Constants and global variables
    /////////////////////////////////////////////////////////////////////////////////////
    const svgns = "http://www.w3.org/2000/svg";
    const kRobberImgPath = "assets/robber.png";
    const kCopImgPath = "assets/cop.png";

    // Logical coordinate: {x,y} where both x and y are between 1 and N
    // inclusive, N = 10.
    // Physical coordinate: {x,y} pixel offset on screen relative to the
    // upper left corner of the svg area.
    // Logical to physical translation is:
    //   physical_coord = logical_coord * {kScaleX, kScaleY} + {kOffsetX, kOffsetY}
    // using functions l2p(). The reverse function are p2lx() and p2l().
    const kScaleX = 140;
    const kScaleY = 120;
    const kOffsetX = 0;
    const kOffsetY = -50;
    const kRadiusRegular = 8;
    const kImgHeight = 50;

    let characters = new Map(); // The game characters, name=>object.
    let adj = [];    // The adjacency list. adj[i] is an array of vertexIds neighboring i.

    /////////////////////////////////////////////////////////////////////////////////////
    // Class definitions
    /////////////////////////////////////////////////////////////////////////////////////

    // Base class for either Cop or Robber. Implements creation of the image element and moving
    // on the graph.
    class GameCharacter {
        constructor(vId, dId, img) {
            this.vertexId = vId; // Position of this character, as index in the vertices array.
            this.docId = dId;
            this.imgPath = img;
            this.create();
            this.draw();
            characters.set(this.docId, this);
        }
        create() {
            let img = document.createElementNS(svgns, "image");
            img.setAttribute("id", this.docId);
            img.setAttribute("height", kImgHeight * 1.2);
            img.setAttribute("href", this.imgPath);
            document.getElementById("svgroot").appendChild(img);
        }
        draw() {
            let e = document.getElementById(this.docId);
            let pu = imgLogicalToPhysical(graph.vertices[this.vertexId]);
            e.setAttribute("x", pu.x);
            e.setAttribute("y", pu.y);
        }
        // If the given vertex id is one of the neighbors in the graph, move to it.
        // Otherwise stay where it was before. Refresh the display either way.
        tryMoveTo(vId) {
            if (vId >= 0) {
                let isEdge = false;
                for (let i = 0; i < graph.edges.length; i++) {
                    if ((vId == graph.edges[i][0] && this.vertexId == graph.edges[i][1]) ||
                        (vId == graph.edges[i][1] && this.vertexId == graph.edges[i][0])) {
                        isEdge = true;
                        break;
                    }
                }
                if (isEdge) {
                    this.vertexId = vId;
                    // TODO: more processing here.
                }
            }
            this.draw();
        }
    }
    // Represents a robber in the game.
    class Robber extends GameCharacter {
        constructor(v) {
            super(v, "id_robber", kRobberImgPath);
        }
    }
    // Represents a cop in the game.
    class Cop extends GameCharacter {
        constructor(v) {
            super(v, "id_cop_" + v, kCopImgPath);
        }
    }

    class GameGraph {
        constructor(data) {
            this.vertices = data.vertices; // Take the vertices array directly from the data.
            this.adj = []; // The adjacency list. adj[i] is an array of vertexIds neighboring i.
            data.edges.forEach((e) => {
                let u = e[0];
                let v = e[1];
                if (this.adj[u] === undefined) {
                    this.adj[u] = [];
                }
                this.adj[u].push(v);
                if (this.adj[v] === undefined) {
                    this.adj[v] = [];
                }
                this.adj[v].push(u);
            });

            this.characters = new Map(); // The game characters, name=>object.
        }
    }

    /////////////////////////////////////////////////////////////////////////////////////
    // Drawing and coordinate translation functions.
    /////////////////////////////////////////////////////////////////////////////////////

    function logicalToPhysical(l) {
        return { x: l.x * kScaleX + kOffsetX, y: l.y * kScaleY + kOffsetY };
    }
    function imgLogicalToPhysical(i) {
        let pcenter = logicalToPhysical(i);
        return { x: pcenter.x - 0.5 * kImgHeight, y: pcenter.y - 0.6 * kImgHeight };
    }
    function physicalToLogical(p) {
        return {
            x: Math.floor((p.x - kOffsetX + 0.5 * kScaleX) / kScaleX),
            y: Math.floor((p.y - kOffsetY + 0.5 * kScaleY) / kScaleY)
        };
    }

    let graph = {
        // The vertices of the graph.
        vertices: [
            { x: 1, y: 1 },
            { x: 4, y: 1 },
            { x: 4, y: 4 },
            { x: 1, y: 4 },
            { x: 2, y: 2 },
            { x: 3, y: 2 },
            { x: 3, y: 3 },
            { x: 2, y: 3 },
            { x: 5, y: 4 },
        ],
        // The edges of the graph, each edge is represented as the from and to vertex
        // index in the vertices array.
        edges: [
            [0, 1], [1, 2], [2, 3], [3, 0],
            [4, 5], [5, 6], [6, 7], [7, 4],
            [0, 4], [1, 5], [2, 6], [3, 7],
            [2, 8], [1, 8]
        ],
        robber: 6,
        cops: [1, 2],
    };


    drawGraph();
    // TODO: change creation to data driven
    new Robber(graph.robber);
    graph.cops.forEach((v) => new Cop(v));

    // Draws the vertex of the given id.
    function drawOneVertex(vertexId) {
        let c = document.createElementNS(svgns, "circle");
        let pv = logicalToPhysical(graph.vertices[vertexId]);
        c.setAttribute("id", "v_" + vertexId);
        c.setAttribute("cx", pv.x);
        c.setAttribute("cy", pv.y);
        c.setAttribute("r", kRadiusRegular);
        c.setAttribute("stroke", "blue");
        c.setAttribute("fill", "white");
        document.getElementById("svgroot").appendChild(c);
    }
    // Draws the given edge e=[e[0],e[1]] where both values are indices in the vertices array.
    function drawOneEdge(e) {
        let u = graph.vertices[e[0]];
        let pu = logicalToPhysical(u);
        let v = graph.vertices[e[1]];
        let pv = logicalToPhysical(v);
        let line = document.createElementNS(svgns, "line");
        line.setAttribute("x1", pu.x);
        line.setAttribute("y1", pu.y);
        line.setAttribute("x2", pv.x);
        line.setAttribute("y2", pv.y);
        line.setAttribute("style", "stroke: blue; stroke-width: 4");
        document.getElementById("svgroot").appendChild(line);
    }
    // Draws the graph (without game characters).
    function drawGraph() {
        graph.edges.forEach(drawOneEdge);
        for (let i = 0; i < graph.vertices.length; i++) {
            drawOneVertex(i);
        }
    }

    // Given a physical coordinate {x,y}, returns the corresponding vertex id,
    // if the coordinate is close enough to a valid vertex. Otherwise returns -1.
    function getVertexId(phy_coord) {
        let l_coord = physicalToLogical(phy_coord);
        for (let i = 0; i < graph.vertices.length; i++) {
            if (l_coord.x == graph.vertices[i].x && l_coord.y == graph.vertices[i].y) {
                console.log("Found " + l_coord);
                return i;
            }
        }
        return -1;
    }

    // Implements the movements of the game characters using mouse drag-and-drop.
    function makeDraggable(evt) {
        let selectedElement = false;
        let selectedCharacter = false;
        let offset = 0;
        let svg = evt.target;
        let candidates = [];

        svg.addEventListener('mousedown', startDrag);
        svg.addEventListener('mousemove', drag);
        svg.addEventListener('mouseup', endDrag);
        svg.addEventListener('mouseleave', endDrag);

        function startDrag(evt) {
            if (characters.has(evt.target.id)) {
                selectedElement = evt.target;
                selectedCharacter = characters.get(selectedElement.id);
                offset = getMousePosition(evt);
                offset.x -= parseFloat(selectedElement.getAttribute("x"));
                offset.y -= parseFloat(selectedElement.getAttribute("y"));


            }
        }

        function drag(evt) {
            if (selectedElement) {
                evt.preventDefault();
                let coord = getMousePosition(evt);
                selectedElement.setAttribute("x", coord.x - offset.x);
                selectedElement.setAttribute("y", coord.y - offset.y);
            }
        }
        function endDrag(evt) {
            if (selectedCharacter) {
                evt.preventDefault();
                let coord = getMousePosition(evt);
                let v = getVertexId(coord);
                selectedCharacter.tryMoveTo(v);
                selectedElement = null;
            }
        }
        function getMousePosition(evt) {
            let CTM = svg.getScreenCTM();
            return {
                x: (evt.clientX - CTM.e) / CTM.a,
                y: (evt.clientY - CTM.f) / CTM.d
            };
        }
    }
</script>