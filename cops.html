---
title: The Cops & Robbers Game
description: Three cops and one robber run on a planar undirected graph. The cops and the robber take turns to move. In each move the person runs from one vertex to a neighbor. Can the cops catch the robber?
layout: default
permalink: /cops
---

<svg id="svgroot" width="1000" height="700" onload="makeDraggable(evt)">
</svg>

<script>
    const svgns = "http://www.w3.org/2000/svg";
    const kRobberImgPath = "assets/robber.png";
    const kCopImgPath = "assets/cop.png";

    // Logical coordinate: {x,y} where both x and y are between 1 and N
    // inclusive, N = 10.
    // Physical coordinate: {x,y} pixel offset on screen relative to the
    // upper left corner of the svg area.
    // Logical to physical translation is:
    //   physical_coord = logical_coord * {kScaleX, kScaleY} + {kOffsetX, kOffsetY}
    // using functions l2p(). The reverse function are p2lx() and p2l().
    const kScaleX = 140;
    const kScaleY = 120;
    const kOffsetX = 0;
    const kOffsetY = -50;
    const kRadius = 50;

    function logicalToPhysical(l) {
        return { x: l.x * kScaleX + kOffsetX, y: l.y * kScaleY + kOffsetY };
    }
    function imgLogicalToPhysical(i) {
        let pcenter = logicalToPhysical(i);
        return { x: pcenter.x - 0.5 * kRadius, y: pcenter.y - 0.6 * kRadius };
    }
    function physicalToLogical(p) {
        return {
            x: Math.floor((p.x - kOffsetX + 0.5 * kScaleX) / kScaleX),
            y: Math.floor((p.y - kOffsetY + 0.5 * kScaleY) / kScaleY)
        };
    }

    // The vertices of the graph.
    let vertices = [
        { x: 1, y: 1 },
        { x: 4, y: 1 },
        { x: 4, y: 4 },
        { x: 1, y: 4 },
        { x: 2, y: 2 },
        { x: 3, y: 2 },
        { x: 3, y: 3 },
        { x: 2, y: 3 },
        { x: 5, y: 4 },
    ];
    // The edges of the graph, each edge is represented as the from and to vertex
    // index in the vertices array.
    let edges = [
        [0, 1], [1, 2], [2, 3], [3, 0],
        [4, 5], [5, 6], [6, 7], [7, 4],
        [0, 4], [1, 5], [2, 6], [3, 7],
        [2, 8], [1, 8]
    ];

    class GameCharacter {
        constructor(vId, dId, img) {
            this.vertexId = vId; // Position of this character, as index in the vertices array.
            this.docId = dId;
            this.imgPath = img;
            this.create();
            this.draw();
        }
        create() {
            let img = document.createElementNS(svgns, "image");
            img.setAttribute("id", this.docId);
            img.setAttribute("height", kRadius * 1.2);
            img.setAttribute("href", this.imgPath);
            document.getElementById("svgroot").appendChild(img);
        }
        draw() {
            let e = document.getElementById(this.docId);
            let pu = imgLogicalToPhysical(vertices[this.vertexId]);
            e.setAttribute("x", pu.x);
            e.setAttribute("y", pu.y);
        }
        tryMoveTo(vId) {
            if (vId >= 0) {
                let isEdge = false;
                for (let i = 0; i < edges.length; i++) {
                    if ((vId == edges[i][0] && this.vertexId == edges[i][1]) ||
                        (vId == edges[i][1] && this.vertexId == edges[i][0])) {
                        isEdge = true;
                        break;
                    }
                }
                if (isEdge) {
                    this.vertexId = vId;
                    // TODO: more processing here.
                }
            }
            this.draw();
        }
    }
    class Robber extends GameCharacter {
        constructor(v) {
            super(v, "id_robber", kRobberImgPath);
        }
    }
    class Cop extends GameCharacter {
        constructor(v) {
            super(v, "id_cop", kCopImgPath);
        }
    }

    let selectedElement = false;
    let offset = 0;
    drawGraph();
    let robber = new Robber(6);
    let cop = new Cop(1);

    // Draw the given vertex v={x,y} in logical coordinate.
    function drawOneVertex(v) {
        let c = document.createElementNS(svgns, "circle");
        let pv = logicalToPhysical(v);
        c.setAttribute("cx", pv.x);
        c.setAttribute("cy", pv.y);
        c.setAttribute("r", kRadius);
        c.setAttribute("stroke", "blue");
        c.setAttribute("fill", "white");
        document.getElementById("svgroot").appendChild(c);
    }
    function drawOneEdge(e) {
        let u = vertices[e[0]];
        let pu = logicalToPhysical(u);
        let v = vertices[e[1]];
        let pv = logicalToPhysical(v);
        let line = document.createElementNS(svgns, "line");
        line.setAttribute("x1", pu.x);
        line.setAttribute("y1", pu.y);
        line.setAttribute("x2", pv.x);
        line.setAttribute("y2", pv.y);
        line.setAttribute("style", "stroke: blue; stroke-width: 4");
        document.getElementById("svgroot").appendChild(line);
    }
    function drawGraph() {
        edges.forEach(drawOneEdge);
        vertices.forEach(drawOneVertex);
    }

    function getVertexId(phy_coord) {
        let l_coord = physicalToLogical(phy_coord);
        for (let i = 0; i < vertices.length; i++) {
            if (l_coord.x == vertices[i].x && l_coord.y == vertices[i].y) {
                console.log("Found " + l_coord);
                return i;
            }
        }
        return -1;
    }
    function moveTo(cid, v) {
        if (cid == "id_robber") {
            robberPos = v;
        } else {
            copPos = v;
        }
    }

    function makeDraggable(evt) {
        let svg = evt.target;
        svg.addEventListener('mousedown', startDrag);
        svg.addEventListener('mousemove', drag);
        svg.addEventListener('mouseup', endDrag);
        svg.addEventListener('mouseleave', endDrag);

        function startDrag(evt) {
            if (evt.target.id === "id_cop" || event.target.id === "id_robber") {
                selectedElement = evt.target;
                offset = getMousePosition(evt);
                offset.x -= parseFloat(selectedElement.getAttribute("x"));
                offset.y -= parseFloat(selectedElement.getAttribute("y"));
            }
        }

        function drag(evt) {
            if (selectedElement) {
                evt.preventDefault();
                let coord = getMousePosition(evt);
                selectedElement.setAttribute("x", coord.x - offset.x);
                selectedElement.setAttribute("y", coord.y - offset.y);
            }
        }
        function endDrag(evt) {
            if (selectedElement) {
                let c = selectedElement.id == "id_robber" ? robber : cop;
                selectedElement = null;

                evt.preventDefault();
                let coord = getMousePosition(evt);
                let v = getVertexId(coord);
                c.tryMoveTo(v);
            }
        }
        function getMousePosition(evt) {
            let CTM = svg.getScreenCTM();
            return {
                x: (evt.clientX - CTM.e) / CTM.a,
                y: (evt.clientY - CTM.f) / CTM.d
            };
        }
    }
</script>