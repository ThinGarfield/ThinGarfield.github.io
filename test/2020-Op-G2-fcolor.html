<html>

<head>
    <script
        type="text/x-mathjax-config"> MathJax.Hub.Config({ tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});</script>
    <script type="text/javascript"
        src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</head>

<body>
    <H1>USACO 2020 US Open Contest, Gold, Problem 2. Favorite Colors</H1>
    Problem <a href=http://usaco.org/index.php?page=viewproblem2&cpid=1042>link</a>.

    <H2> Analysis</H2>
    We model the graph as: $i \rightarrow j$ iff cow $j$ admires $i$. The illustration of the graph
    is already in the problem statement on the USACO site. With this, the problem becomes how to
    efficiently merge graph vertices in a way that if $i \rightarrow v_k$ for $k \in \{1,2,\cdots,s\}$, then we merge
    all
    $k_j$ into a single vertex in the graph. We keep doing that until the
    out-degree of all vertices in the graph are 0 or 1. Then it would satisfy the problem requirement
    that "if cows $x$ and $y$ both admire a cow with favorite color $c$, then $x$ and $y$ share the same favorite
    color".

    To satisfy the lexicographically smallest requirement, we simply always merge the vertices into
    the smaller index.

    <H2>Code Idea</H2>
    To represent the graph: vertices are $1,2,\cdots,n$. The edges are represented in the `edges` array,
    with each vertice's directed neighbors represented in a `set` (for efficient dedup during merging).

    We use `parent` array to represent the merged parent. `parent[1] = 3` indicates that 3 is merged
    into 1. We use `children` array to represent the merged children, to effectively remove
    duplicates, we use a `set` to represent the children of each parent.

    Finally, we use a `todo` queue to store what vertices need to be processed. All vertices that
    have out-degree $>1$ need to be added to the `todo` queue and processed.

    <H2>Code</H2>
    <p>
    <pre>
#define OUTPUT_FILE "fcolor.out"
#define INPUT_FILE "fcolor.in"

#include <bits/stdc++.h>
using namespace std;

constexpr int maxn = 200005;
int parent[maxn]{};
set<int> children[maxn];
int color[maxn]{};
set<int> edges[maxn];
int n, m;
queue<int> todo;

// For a given vertex a, if it has more than 1 neighbor, merge
// them together into the smallest indexed neighbor.
// The merge consists of setting (1) parent (2) parent's children set
// (3) edges outgoing from parent.
void process(int a) {
    if (edges[a].size() > 1) {
        int root = maxn;
        for (int b : edges[a]) {
            root = min(root, parent[b]);
        }
        for (int b : edges[a]) {
            int p = parent[b];
            if (p == root) continue;
            for (int c : children[p]) {
                parent[c] = root;
                children[root].emplace(c);
            }
            children[p].clear();
            for (int d : edges[p]) {
                edges[root].emplace(parent[d]);
            }
        }
        if (edges[root].size() > 1) {
            todo.push(root);
        }
        edges[a].clear();
        edges[a].emplace(root);
    }
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    ifstream fin(INPUT_FILE);
    ofstream fout(OUTPUT_FILE);

    fin >> n >> m;
    for (int i = 1; i <= n; i++) {
        parent[i] = i;
        children[i].emplace(i);
    }

    for (int i = 0; i < m; i++) {
        int a, b;
        fin >> a >> b;
        edges[a].emplace(b);
    }

    for (int i = 1; i <= n; i++) {
        process(i);
    }
    while (!todo.empty()) {
        int i = todo.front();
        todo.pop();
        process(i);
    }

    int nextColor = 1;
    for (int i = 1; i <= n; i++) {
        if (parent[i] == i) {
            color[i] = nextColor++;
        }
    }

    for (int i = 1; i <= n; i++) {
        fout << color[parent[i]] << '\n';
    }

    fin.close();
    fout.close();
    return 0;
}
</pre>
    </p>
</body>

</html>