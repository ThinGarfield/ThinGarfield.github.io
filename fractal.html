---
title: Fractal - Mandelbrot Set
description: The beautiful Mandelbrot &amp; Julia set.
layout: default
permalink: /fractal
---

<div>
    <p>
    <div>
        <div id="desc_mandelbrot" style="display: block;">
            <b>Mandelbrot set:</b> for $z, a\in \mathbb C$, define $f_z(a)=a^2+z$, and
            $f_z^{(n)}(a) = f_z \left( f_z \left( \cdots f_z(a) \cdots\right) \right) $ where $f_z$ is applied
            $n$ times. Given a threshold $M\in \mathbb R^+$, for each $z=x+yi\in \mathbb C$,
            compute the smallest $n$ such that $\bigm|f_z^{(n)}(0)\bigm| > M$, and assign the color at
            coordinates $(x,y)$ according to the value of $n$. And Voila!
        </div>
        <div id="desc_julia" style="display: none;">
            <b>Julia set:</b> for $w, z\in \mathbb C$, define $f_w(z)=z^2+w$, and
            $f_w^{(n)}(z) = f_w \left( f_w \left( \cdots f_w(z) \cdots\right) \right) $ where $f_w$ is applied
            $n$ times. Given a threshold $M\in \mathbb R^+$, and $w\in \mathbb C$,
            for each $z=x+yi\in \mathbb C$,
            compute the smallest $n$ such that $\bigm|f_w^{(n)}(z)\bigm| > M$, and assign the color at
            coordinates $(x,y)$ according to the value of $n$. And Voila!
        </div>
    </div>
    </p>
    <p>
        Below you can switch between Mandelbrot and Julia sets. You can adjust the size, the maximum number of iterations,
        the threshold $M$, and the color palette, by using the sliders. In case of Julia set, you can also click on the gray square
        to change the value of $w$. The computation runs in
        your browser, be patient, it may take a few sections after you release the slider for the image
        to update. (Tip: smaller image size runs faster.)
    </p>
    <p>Double click on the image to zoom in. Double click while holding "Shift" key to zoom out. Drag the image to move.</p>
</div>
<div>
    <table>
        <tr>
            <td rowspan="2">
                <input type="radio" name="sets" value="mandelbrot" onchange="onSetChange()" checked />
                <lable><b>Mandelbrot</b></lable><br />
                <input type="radio" name="sets" value="julia" onchange="onSetChange()" />
                <lable><b>Julia</b></lable>
            </td>
            <th>Image Size :<br> <span id="imgSizeVal">900*600</span></th>
            <th>Max Iterations: <br> <span id="maxIterVal">500</span></th>
            <th>Threshold $M$ :<br> <span id="thresholdVal">4.0</span></th>
            <th>Color Palette :<br> <span id="colorVal">0</span></th>
            <th id="juliaValZCell">$w=$ <br><span id="juliaValZ"></span></th>
        </tr>
        <tr>
            <td><input type="range" min="400" max="1600" value="600" class="slider" oninput="onSizeInput(this.value)" onchange=" onSizeChange(this.value)"></td>
            <td><input type="range" min="500" max="5000" value="500" class="slider" oninput="onMaxIterationInput(this.value)" onchange="onMaxIterationChange(this.value)"></td>
            <td><input type="range" min="200" max="600" value="400" class="slider" oninput="onThresholdInput(this.value)" onchange=" onThresholdChange(this.value)"></td>
            <td><input type="range" min="0" max="100" value="0" class="slider" oninput="onColorInput(this.value)" onchange=" onColorChange(this.value)"></td>
            <td id="juliaZCell">
                <canvas id="juliaZ" width="100" height="100" onmousedown="onJuliaZStart(event)" onmouseup="onJuliaZEnd(event)" onmousemove="onJuliaZMove(event)">
                </canvas>
            </td>
        </tr>
    </table>
</div>

<div>
    <canvas id="mandelbrot" class="fractal" width="960" height="600" ondblclick="onZoomIn(event)" onmousedown="onStartDrag(event)" onmouseup="onEndDrag(event)">
    </canvas>
</div>

<script>
    ////////////////////////////////////////////////////////////////////////////////
    // This section defines the global variables and initializes everything.
    ////////////////////////////////////////////////////////////////////////////////

    // Used in translating iteration number into color values.
    const byteSquared = 256 * 256;
    const byteCubed = 256 * 256 * 256 - 1;
    const zoomRatio = 4; // ratio in each step of zoom in/out.
    let threshold = 4.0; // The threshold M.
    let colorOffset = 0.0; // The color palette seed.
    let maxIterations = 500;
    let isJulia = false; // true:Julia, false:Mandelbrot.
    let aspectRatio = 0; // width:height ratio

    // For Julia set only: w = (wx) + i(wy)
    let wx = 0;
    let wy = 0;

    // The boundary of the logical coordinates (x,y) in the complex plane.
    let ymin = 0;
    let ymax = 0;
    let xmax = 0;
    let xmin = 0;

    resetAll();
    showFractal();

    function resetAll() {
        if (isJulia) {
            aspectRatio = 1;
            wx = -0.7269;
            wy = 0.1889;
            document.getElementById("desc_mandelbrot").style.display = "none";
            document.getElementById("desc_julia").style.display = "block";
            document.getElementById("juliaZCell").style.display = "block";
            document.getElementById("juliaValZCell").style.display = "block";
            updateJuliaZ();
        } else {
            aspectRatio = 1.5;
            document.getElementById("desc_julia").style.display = "none";
            document.getElementById("desc_mandelbrot").style.display = "block";
            document.getElementById("juliaZCell").style.display = "none";
            document.getElementById("juliaValZCell").style.display = "none";
        }
        ymin = -1;
        ymax = 1;
        xmax = 1;
        xmin = 1 - 2 * aspectRatio;
        let canvas = document.getElementById('mandelbrot');
        canvas.width = Math.floor(canvas.height * aspectRatio);
        document.getElementById("imgSizeVal").innerHTML = canvas.width.toString() + "*" + canvas.height.toString();
    }
    function updateJuliaZ() {
        document.getElementById("juliaValZ").innerHTML = wx.toPrecision(2) + "+" + wy.toPrecision(2) + "i";
        let canvas = document.getElementById("juliaZ");
        let ctx = canvas.getContext('2d');
        ctx.fillStyle = "#dddddd";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.beginPath();
        let px = canvas.width / 2 * (1 + wx);
        let py = canvas.height / 2 * (1 + wy);
        ctx.arc(px, py, 3, 0, 2 * Math.PI);
        ctx.stroke();
        ctx.fillStyle = "#2222ff";
        ctx.fill();
    }

    ////////////////////////////////////////////////////////////////////////////////
    // This section deals with the changes of the controls.
    ////////////////////////////////////////////////////////////////////////////////

    function onSizeInput(v) {
        document.getElementById("imgSizeVal").innerHTML = Math.floor(v * aspectRatio).toString() + "*" + v.toString();
    }
    function onSizeChange(v) {
        let canvas = document.getElementById('mandelbrot');
        canvas.height = v;
        canvas.width = Math.floor(v * aspectRatio);
        showFractal();
    }
    function onMaxIterationInput(v) {
        document.getElementById("maxIterVal").innerHTML = v;
    }
    function onMaxIterationChange(v) {
        maxIterations = v;
        showFractal();
    }
    function onThresholdInput(v) {
        document.getElementById("thresholdVal").innerHTML = v / 100;
    }
    function onThresholdChange(v) {
        threshold = v / 100;
        showFractal();
    }
    function onColorInput(v) {
        document.getElementById("colorVal").innerHTML = v / 100;
    }
    function onColorChange(v) {
        colorOffset = v / 100;
        showFractal();
    }
    function onSetChange() {
        let radios = document.getElementsByName("sets");
        let isJuliaChecked = false;
        for (let i = 0; i < radios.length; i++) {
            if (radios[i].checked) {
                isJuliaChecked = radios[i].value === "julia";
            }
        }
        if (isJulia !== isJuliaChecked) {
            isJulia = isJuliaChecked;
            resetAll();
            showFractal();
        }
    }

    ////////////////////////////////////////////////////////////////////////////////
    // This section deals with mouse double click and drag of the main canvas
    ////////////////////////////////////////////////////////////////////////////////
    let juliaZStarted = false;
    function onJuliaZStart(event) {
        juliaZStarted = true;
        onJuliaZMove(event);
    }
    function onJuliaZEnd(event) {
        if (juliaZStarted) {
            juliaZStarted = false;
            showFractal();
        }
    }
    function onJuliaZMove(event) {
        if (juliaZStarted) {
            let canvas = document.getElementById("juliaZ");
            let px = event.offsetX;
            let py = event.offsetY;
            if (px < 0) px = 0;
            if (px > canvas.width) px = canvas.width;
            if (py < 0) py = 0;
            if (py > canvas.height) py = canvas.height;
            wx = px * 2 / canvas.width - 1;
            wy = py * 2 / canvas.height - 1;
            updateJuliaZ();
        }
    }

    ////////////////////////////////////////////////////////////////////////////////
    // This section deals with mouse double click and drag of the main canvas
    ////////////////////////////////////////////////////////////////////////////////

    // Used in start/end drag event handlers.
    let isInDrag = false;
    let startDragX = 0;
    let startDragY = 0;

    function onZoomIn(event) {
        isInDrag = false;
        let zoomOut = event.getModifierState("Shift"); // Check whether shift-key is down.
        let canvas = document.getElementById('mandelbrot');
        let x = event.offsetX / canvas.width * (xmax - xmin) + xmin;
        let y = event.offsetY / canvas.height * (ymax - ymin) + ymin;
        let w = zoomOut ? (xmax - xmin) * zoomRatio : (xmax - xmin) / zoomRatio;
        let h = zoomOut ? (ymax - ymin) * zoomRatio : (ymax - ymin) / zoomRatio;
        xmax = x + w / 2; xmin = x - w / 2;
        ymax = y + h / 2; ymin = y - h / 2;
        showFractal();
    }
    function onStartDrag(event) {
        isInDrag = true;
        startDragX = event.offsetX;
        startDragY = event.offsetY;
    }
    function onEndDrag(event) {
        if (isInDrag) {
            isInDrag = false;
            let canvas = document.getElementById('mandelbrot');
            let xDiff = (event.offsetX - startDragX) / canvas.width * (xmax - xmin);
            let yDiff = (event.offsetY - startDragY) / canvas.height * (ymax - ymin);
            xmax -= xDiff; xmin -= xDiff;
            ymax -= yDiff; ymin -= yDiff;
            showFractal();
        }
    }

    ////////////////////////////////////////////////////////////////////////////////
    // This section performs the actual computation and drawing.
    ////////////////////////////////////////////////////////////////////////////////

    function showFractal() {
        document.body.style.cursor = 'wait';
        document.getElementById('mandelbrot').style.opacity = "0.3";
        setTimeout(showFractalInternal, 50);
    }

    function showFractalInternal() {
        let canvas = document.getElementById('mandelbrot');

        // Get the image data and pixels array from the canvas, in order to draw on it.
        let ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        let imgdata = ctx.getImageData(0, 0, canvas.width, canvas.height);
        let pixels = imgdata.data;

        // (px, py) are the physical coordinates on the canvas.
        for (let px = 0; px < canvas.width; px++) {
            for (let py = 0; py < canvas.height; py++) {
                // Calculates the logical coordinates (cx, cy) from the physical coord (px, py).
                let cx = px / canvas.width * (xmax - xmin) + xmin;
                let cy = py / canvas.height * (ymax - ymin) + ymin;
                let idx = (py * imgdata.width + px) * 4;
                // Computes the color value at (x,y) and draw it on the canvas.
                drawPixel(pixels, cx, cy, idx);
            }
        }
        // Everything above just updates the image data, this performs the actual drawing.
        ctx.putImageData(imgdata, 0, 0);
        document.body.style.cursor = 'default';
        document.getElementById('mandelbrot').style.opacity = "1.0";
    }
    // Computes the Mandelbrot value at (x, y),
    // and sets the color in the pixels array at idx.
    function drawPixel(pixels, cx, cy, idx) {
        let i = 0;
        if (isJulia) {
            for (; i < maxIterations && cx * cx + cy * cy <= threshold; i++) {
                let x1 = cx * cx - cy * cy + wx;
                cy = 2 * cx * cy + wy;
                cx = x1;
            }
        } else {
            let x = 0;
            let y = 0;
            for (; i < maxIterations && x * x + y * y <= threshold; i++) {
                let x1 = x * x - y * y + cx;
                y = 2 * x * y + cy;
                x = x1;
            }
        }
        i = (maxIterations - i) * byteCubed / maxIterations;
        i = (i + colorOffset * byteCubed) % (byteCubed + 1);

        var r = Math.floor(i / byteSquared);
        var g = Math.floor((i / 256) % 256);
        var b = Math.floor(i % 256);
        pixels[idx] = r;
        pixels[idx + 1] = g;
        pixels[idx + 2] = b;
        pixels[idx + 3] = 255;
    }
</script>